
(require unstable/exn)
(require mzlib/cml)


(define dl2 200)

(define tree "")
(define bstr "")
(define fl `())
(define len 0)
(define curr 0)
(define count-t 0)
(define en-tree-str "")


(define (init)
  (begin (set! dl2 200)
         (set! tree "")
         (set! bstr "")
         (set! fl `())
         (set! len 0)
         (set! curr 0)
         (set! count-t 0)))


(define (decompress-huffman output input)
  (init)
  (define l (bytes->list (file->bytes input)))
  (define lst-bit (cdr l))
  (define (decompress-tree lst no)
    (if (and (>= (car lst) 48) (<= (car lst) 57)) (decompress-tree (cdr lst) (+ (* no 10) (- (car lst) 48)))
        (begin
          (set! fl (drop lst (- no 1)))
          (set! bstr (string-append (foldr (Î» (x y) (string-append (extend-bn (number->binary x) 8) y)) 
                                           "" 
                                           (drop (take fl (- (length fl) 1)) 1))
                                    (extend-bn (number->binary 
                                               (car (drop fl (- (length fl) 1)))) 
                                               (car l))))
          (set! len (length fl))
          (set! en-tree-str (list->string (map (lambda (x) (integer->char x)) (take lst no))))
          (set! tree (decode-tree en-tree-str))
          (display-to-file (helper tree bstr "") output #:exists `replace)
          )))
  (decompress-tree lst-bit 0))

(define (helper t s result)
  (begin (set! count-t (+ count-t 1))
         (cond ((> (- (current-time) curr) dl2) (begin (set! curr (current-time))
                                                       (let ((v (+ 20 (* 80.0 (/ count-t (* 8 len))))))
                                                        (if (> v 100) (progress-bar 100) (progress-bar (floor v)))))))
         (cond ((string=? s "") (if (leaf? t) (string-append result (string (leaf-val t))) result))
               ((leaf? t) (helper tree s (string-append result (string (leaf-val t)))))
               ((char=? (string-ref s 0) #\0) (helper (bnode-ltree t) (substring s 1) result))
               ((char=? (string-ref s 0) #\1) (helper (bnode-rtree t) (substring s 1) result))
               (else (error "invalid input given")))))

(define (separate-blocks str)
  (define (helper s cnt flag)
    (begin (cond ((char=? (string-ref s 0) #\() (if (= flag 1) (set! flag 0) (set! cnt (+ cnt 1))))
                 ((char=? (string-ref s 0) #\)) (if (= flag 2) (set! flag 0) (set! cnt (- cnt 1)))))
           (cond ((try (string=? (substring s 0 4) "(L()") #f) (set! flag 1))
                 ((try (string=? (substring s 0 4) "(L))") #f) (set! flag 2)))
           (cond ((= cnt 0) (substring str 0 (+ 1 (- (string-length str) (string-length s))))) 
                 (else (helper (substring s 1) cnt flag)))))
  (let ((v (helper str 0 0))
        (lstr (string-length str)))
    (cons v (substring str (string-length v) (- lstr 1))))) 

(define (decode-tree strng)
  (define (decode-h st)
    (cond ((string=? (substring st 0 2) "(B") (let ((v (separate-blocks (substring st 2))))
                                                (bnode (decode-h (car v)) (decode-h (cdr v)))))
          ((string=? (substring st 0 2) "(L") (leaf (string-ref st 2)))
          (else (begin (display st)
                       (error "WRONG!!")))))
  (decode-h strng))

(define (extract-tree str)
  (define (extract-num s res)
    (define v (char->integer (string-ref s 0)))
    (if (and (< v 58) (> v 47)) (extract-num (substring s 1) (string-append res (string (integer->char v))))
        (cons (substring s 0 (string->number res)) (substring s (string->number res)))))
  (extract-num str ""))